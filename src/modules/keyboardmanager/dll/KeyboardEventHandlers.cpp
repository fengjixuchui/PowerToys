#include "pch.h"
#include "KeyboardEventHandlers.h"
#include "keyboardmanager/common/Shortcut.h"
#include "keyboardmanager/common/RemapShortcut.h"
#include "../common/shared_constants.h"
#include <keyboardmanager/common/KeyboardManagerState.h>
#include <keyboardmanager/common/InputInterface.h>
#include <keyboardmanager/common/Helpers.h>
#include <keyboardmanager/common/trace.h>

namespace KeyboardEventHandlers
{
    // Function to a handle a single key remap
    __declspec(dllexport) intptr_t HandleSingleKeyRemapEvent(InputInterface& ii, LowlevelKeyboardEvent* data, KeyboardManagerState& keyboardManagerState) noexcept
    {
        // Check if the key event was generated by KeyboardManager to avoid remapping events generated by us.
        if (!(data->lParam->dwExtraInfo & CommonSharedConstants::KEYBOARDMANAGER_INJECTED_FLAG))
        {
            auto& remapping = keyboardManagerState.GetSingleKeyRemap(data->lParam->vkCode);
            if (remapping)
            {
                auto it = remapping.value();

                // Check if the remap is to a key or a shortcut
                bool remapToKey = (it->second.index() == 0);

                // If mapped to VK_DISABLED then the key is disabled
                if (remapToKey)
                {
                    if (std::get<DWORD>(it->second) == CommonSharedConstants::VK_DISABLED)
                    {
                        return 1;
                    }
                }

                int key_count;
                if (remapToKey)
                {
                    key_count = 1;
                }
                else
                {
                    key_count = std::get<Shortcut>(it->second).Size() + KeyboardManagerConstants::DUMMY_KEY_EVENT_SIZE;
                }
                LPINPUT keyEventList = new INPUT[size_t(key_count)]();
                memset(keyEventList, 0, sizeof(keyEventList));

                // Handle remaps to VK_WIN_BOTH
                DWORD target;
                if (remapToKey)
                {
                    target = KeyboardManagerHelper::FilterArtificialKeys(std::get<DWORD>(it->second));
                }
                else
                {
                    target = KeyboardManagerHelper::FilterArtificialKeys(std::get<Shortcut>(it->second).GetActionKey());
                }

                // If Ctrl/Alt/Shift is being remapped to Caps Lock, then reset the modifier key state to fix issues in certain IME keyboards where the IME shortcut gets invoked since it detects that the modifier and Caps Lock is pressed even though it is suppressed by the hook - More information at the GitHub issue https://github.com/microsoft/PowerToys/issues/3397
                if (data->wParam == WM_KEYDOWN || data->wParam == WM_SYSKEYDOWN)
                {
                    ResetIfModifierKeyForLowerLevelKeyHandlers(ii, it->first, target);
                }

                if (remapToKey)
                {
                    if (data->wParam == WM_KEYUP || data->wParam == WM_SYSKEYUP)
                    {
                        KeyboardManagerHelper::SetKeyEvent(keyEventList, 0, INPUT_KEYBOARD, (WORD)target, KEYEVENTF_KEYUP, KeyboardManagerConstants::KEYBOARDMANAGER_SINGLEKEY_FLAG);
                    }
                    else
                    {
                        KeyboardManagerHelper::SetKeyEvent(keyEventList, 0, INPUT_KEYBOARD, (WORD)target, 0, KeyboardManagerConstants::KEYBOARDMANAGER_SINGLEKEY_FLAG);
                    }
                }
                else
                {
                    int i = 0;
                    Shortcut targetShortcut = std::get<Shortcut>(it->second);
                    if (data->wParam == WM_KEYUP || data->wParam == WM_SYSKEYUP)
                    {
                        KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)targetShortcut.GetActionKey(), KEYEVENTF_KEYUP, KeyboardManagerConstants::KEYBOARDMANAGER_SINGLEKEY_FLAG);
                        i++;
                        KeyboardManagerHelper::SetModifierKeyEvents(targetShortcut, ModifierKey::Disabled, keyEventList, i, false, KeyboardManagerConstants::KEYBOARDMANAGER_SINGLEKEY_FLAG);
                        KeyboardManagerHelper::SetDummyKeyEvent(keyEventList, i, KeyboardManagerConstants::KEYBOARDMANAGER_SINGLEKEY_FLAG);
                    }
                    else
                    {
                        KeyboardManagerHelper::SetDummyKeyEvent(keyEventList, i, KeyboardManagerConstants::KEYBOARDMANAGER_SINGLEKEY_FLAG);
                        KeyboardManagerHelper::SetModifierKeyEvents(targetShortcut, ModifierKey::Disabled, keyEventList, i, true, KeyboardManagerConstants::KEYBOARDMANAGER_SINGLEKEY_FLAG);
                        KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)targetShortcut.GetActionKey(), 0, KeyboardManagerConstants::KEYBOARDMANAGER_SINGLEKEY_FLAG);
                        i++;
                    }
                }

                UINT res = ii.SendVirtualInput(key_count, keyEventList, sizeof(INPUT));
                delete[] keyEventList;

                if (data->wParam == WM_KEYDOWN || data->wParam == WM_SYSKEYDOWN)
                {
                    // Log telemetry event when the key remap is invoked
                    Trace::KeyRemapInvoked(remapToKey);

                    // If Caps Lock is being remapped to Ctrl/Alt/Shift, then reset the modifier key state to fix issues in certain IME keyboards where the IME shortcut gets invoked since it detects that the modifier and Caps Lock is pressed even though it is suppressed by the hook - More information at the GitHub issue https://github.com/microsoft/PowerToys/issues/3397
                    if (remapToKey)
                    {
                        ResetIfModifierKeyForLowerLevelKeyHandlers(ii, target, it->first);
                    }
                    else
                    {
                        std::vector<DWORD> shortcutKeys = std::get<Shortcut>(it->second).GetKeyCodes();
                        for (auto& itSk : shortcutKeys)
                        {
                            ResetIfModifierKeyForLowerLevelKeyHandlers(ii, itSk, it->first);
                        }
                    }
                }

                return 1;
            }
        }

        return 0;
    }

    /* This feature has not been enabled (code from proof of concept stage)
    * 
    // Function to a change a key's behavior from toggle to modifier
    __declspec(dllexport) intptr_t HandleSingleKeyToggleToModEvent(InputInterface& ii, LowlevelKeyboardEvent* data, KeyboardManagerState& keyboardManagerState) noexcept
    {
        // Check if the key event was generated by KeyboardManager to avoid remapping events generated by us.
        if (!(data->lParam->dwExtraInfo & CommonSharedConstants::KEYBOARDMANAGER_INJECTED_FLAG))
        {
            // The mutex should be unlocked before SendInput is called to avoid re-entry into the same mutex. More details can be found at https://github.com/microsoft/PowerToys/pull/1789#issuecomment-607555837
            std::unique_lock<std::mutex> lock(keyboardManagerState.singleKeyToggleToMod_mutex);
            auto it = keyboardManagerState.singleKeyToggleToMod.find(data->lParam->vkCode);
            if (it != keyboardManagerState.singleKeyToggleToMod.end())
            {
                // To avoid long presses (which leads to continuous keydown messages) from toggling the key on and off
                if (data->wParam == WM_KEYDOWN || data->wParam == WM_SYSKEYDOWN)
                {
                    if (it->second == false)
                    {
                        keyboardManagerState.singleKeyToggleToMod[data->lParam->vkCode] = true;
                    }
                    else
                    {
                        lock.unlock();
                        return 1;
                    }
                }
                int key_count = 2;
                LPINPUT keyEventList = new INPUT[size_t(key_count)]();
                memset(keyEventList, 0, sizeof(keyEventList));
                KeyboardManagerHelper::SetKeyEvent(keyEventList, 0, INPUT_KEYBOARD, (WORD)data->lParam->vkCode, 0, KeyboardManagerConstants::KEYBOARDMANAGER_SINGLEKEY_FLAG);
                KeyboardManagerHelper::SetKeyEvent(keyEventList, 1, INPUT_KEYBOARD, (WORD)data->lParam->vkCode, KEYEVENTF_KEYUP, KeyboardManagerConstants::KEYBOARDMANAGER_SINGLEKEY_FLAG);

                lock.unlock();
                UINT res = ii.SendVirtualInput(key_count, keyEventList, sizeof(INPUT));
                delete[] keyEventList;

                // Reset the long press flag when the key has been lifted.
                if (data->wParam == WM_KEYUP || data->wParam == WM_SYSKEYUP)
                {
                    lock.lock();
                    keyboardManagerState.singleKeyToggleToMod[data->lParam->vkCode] = false;
                    lock.unlock();
                }

                return 1;
            }
        }

        return 0;
    }
    */

    // Function to a handle a shortcut remap
    __declspec(dllexport) intptr_t HandleShortcutRemapEvent(InputInterface& ii, LowlevelKeyboardEvent* data, KeyboardManagerState& keyboardManagerState, const std::optional<std::wstring>& activatedApp) noexcept
    {
        // Check if any shortcut is currently in the invoked state
        bool isShortcutInvoked = keyboardManagerState.CheckShortcutRemapInvoked(activatedApp);

        // Get shortcut table for given activatedApp
        ShortcutRemapTable& reMap = keyboardManagerState.GetShortcutRemapTable(activatedApp);

        // Iterate through the shortcut remaps and apply whichever has been pressed
        for (auto& itShortcut : keyboardManagerState.GetSortedShortcutRemapVector(activatedApp))
        {
            auto& it = reMap.find(itShortcut);

            // If a shortcut is currently in the invoked state then skip till the shortcut that is currently invoked
            if (isShortcutInvoked && !it->second.isShortcutInvoked)
            {
                continue;
            }
            // Check if the remap is to a key or a shortcut
            bool remapToShortcut = (it->second.targetShortcut.index() == 1);

            const size_t src_size = it->first.Size();
            const size_t dest_size = remapToShortcut ? std::get<Shortcut>(it->second.targetShortcut).Size() : 1;

            // If the shortcut has been pressed down
            if (!it->second.isShortcutInvoked && it->first.CheckModifiersKeyboardState(ii))
            {
                if (data->lParam->vkCode == it->first.GetActionKey() && (data->wParam == WM_KEYDOWN || data->wParam == WM_SYSKEYDOWN))
                {
                    // Check if any other keys have been pressed apart from the shortcut. If true, then check for the next shortcut. This is to be done only for shortcut to shortcut remaps
                    if (!it->first.IsKeyboardStateClearExceptShortcut(ii) && (remapToShortcut || std::get<DWORD>(it->second.targetShortcut) == CommonSharedConstants::VK_DISABLED))
                    {
                        continue;
                    }

                    size_t key_count;
                    LPINPUT keyEventList;

                    // Remember which win key was pressed initially
                    if (ii.GetVirtualKeyState(VK_RWIN))
                    {
                        it->second.winKeyInvoked = ModifierKey::Right;
                    }
                    else if (ii.GetVirtualKeyState(VK_LWIN))
                    {
                        it->second.winKeyInvoked = ModifierKey::Left;
                    }

                    if (remapToShortcut)
                    {
                        // Get the common keys between the two shortcuts
                        int commonKeys = it->first.GetCommonModifiersCount(std::get<Shortcut>(it->second.targetShortcut));

                        // If the original shortcut modifiers are a subset of the new shortcut
                        if (commonKeys == src_size - 1)
                        {
                            // key down for all new shortcut keys except the common modifiers
                            key_count = dest_size - commonKeys;
                            keyEventList = new INPUT[key_count]();
                            memset(keyEventList, 0, sizeof(keyEventList));
                            int i = 0;
                            KeyboardManagerHelper::SetModifierKeyEvents(std::get<Shortcut>(it->second.targetShortcut), it->second.winKeyInvoked, keyEventList, i, true, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG, it->first);
                            KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)std::get<Shortcut>(it->second.targetShortcut).GetActionKey(), 0, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                            i++;
                        }
                        else
                        {
                            // Dummy key, key up for all the original shortcut modifier keys and key down for all the new shortcut keys but common keys in each are not repeated
                            key_count = KeyboardManagerConstants::DUMMY_KEY_EVENT_SIZE + (src_size - 1) + (dest_size) - (2 * (size_t)commonKeys);
                            keyEventList = new INPUT[key_count]();
                            memset(keyEventList, 0, sizeof(keyEventList));

                            // Send dummy key
                            int i = 0;
                            KeyboardManagerHelper::SetDummyKeyEvent(keyEventList, i, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);

                            // Release original shortcut state (release in reverse order of shortcut to be accurate)
                            KeyboardManagerHelper::SetModifierKeyEvents(it->first, it->second.winKeyInvoked, keyEventList, i, false, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG, std::get<Shortcut>(it->second.targetShortcut));

                            // Set new shortcut key down state
                            KeyboardManagerHelper::SetModifierKeyEvents(std::get<Shortcut>(it->second.targetShortcut), it->second.winKeyInvoked, keyEventList, i, true, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG, it->first);
                            KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)std::get<Shortcut>(it->second.targetShortcut).GetActionKey(), 0, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                            i++;
                        }

                        // Modifier state reset might be required for this key depending on the shortcut's action and target modifiers - ex: Win+Caps -> Ctrl+A
                        if (it->first.GetCtrlKey() == NULL && it->first.GetAltKey() == NULL && it->first.GetShiftKey() == NULL)
                        {
                            Shortcut temp = std::get<Shortcut>(it->second.targetShortcut);
                            for (auto keys : temp.GetKeyCodes())
                            {
                                ResetIfModifierKeyForLowerLevelKeyHandlers(ii, keys, data->lParam->vkCode);
                            }
                        }
                    }
                    else
                    {
                        // Dummy key, key up for all the original shortcut modifier keys and key down for remapped key
                        key_count = KeyboardManagerConstants::DUMMY_KEY_EVENT_SIZE + (src_size - 1) + dest_size;
                        // Do not send Disable key
                        if (std::get<DWORD>(it->second.targetShortcut) == CommonSharedConstants::VK_DISABLED)
                        {
                            key_count--;
                        }

                        keyEventList = new INPUT[key_count]();
                        memset(keyEventList, 0, sizeof(keyEventList));

                        // Send dummy key
                        int i = 0;
                        KeyboardManagerHelper::SetDummyKeyEvent(keyEventList, i, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);

                        // Release original shortcut state (release in reverse order of shortcut to be accurate)
                        KeyboardManagerHelper::SetModifierKeyEvents(it->first, it->second.winKeyInvoked, keyEventList, i, false, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);

                        // Set target key down state
                        if (std::get<DWORD>(it->second.targetShortcut) != CommonSharedConstants::VK_DISABLED)
                        {
                            KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)KeyboardManagerHelper::FilterArtificialKeys(std::get<DWORD>(it->second.targetShortcut)), 0, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                            i++;
                        }

                        // Modifier state reset might be required for this key depending on the shortcut's action and target modifier - ex: Win+Caps -> Ctrl
                        if (it->first.GetCtrlKey() == NULL && it->first.GetAltKey() == NULL && it->first.GetShiftKey() == NULL)
                        {
                            ResetIfModifierKeyForLowerLevelKeyHandlers(ii, (WORD)KeyboardManagerHelper::FilterArtificialKeys(std::get<DWORD>(it->second.targetShortcut)), data->lParam->vkCode);
                        }
                    }

                    it->second.isShortcutInvoked = true;
                    // If app specific shortcut is invoked, store the target application
                    if (activatedApp)
                    {
                        keyboardManagerState.SetActivatedApp(*activatedApp);
                    }

                    UINT res = ii.SendVirtualInput((UINT)key_count, keyEventList, sizeof(INPUT));
                    delete[] keyEventList;

                    // Log telemetry event when shortcut remap is invoked
                    Trace::ShortcutRemapInvoked(remapToShortcut, activatedApp.has_value());

                    return 1;
                }
            }
            // The shortcut has already been pressed down at least once, i.e. the shortcut has been invoked
            // There are 6 cases to be handled if the shortcut has been pressed down
            // 1. The user lets go of one of the modifier keys - reset the keyboard back to the state of the keys actually being pressed down
            // 2. The user keeps the shortcut pressed - the shortcut is repeated (for example you could hold down Ctrl+V and it will keep pasting)
            // 3. The user lets go of the action key - keep modifiers of the new shortcut until some other key event which doesn't apply to the original shortcut
            // 4. The user presses a modifier key in the original shortcut - suppress that key event since the original shortcut is already held down physically (This case can occur only if a user has a duplicated modifier key (possibly by remapping) or if user presses both L/R versions of a modifier remapped with "Both")
            // 5. The user presses any key apart from the action key or a modifier key in the original shortcut - revert the keyboard state to just the original modifiers being held down along with the current key press
            // 6. The user releases any key apart from original modifier or original action key - This can't happen since the key down would have to happen first, which is handled above
            else if (it->second.isShortcutInvoked)
            {
                // Get the common keys between the two shortcuts
                int commonKeys = remapToShortcut ? it->first.GetCommonModifiersCount(std::get<Shortcut>(it->second.targetShortcut)) : 0;

                // Case 1: If any of the modifier keys of the original shortcut are released before the action key
                if ((it->first.CheckWinKey(data->lParam->vkCode) || it->first.CheckCtrlKey(data->lParam->vkCode) || it->first.CheckAltKey(data->lParam->vkCode) || it->first.CheckShiftKey(data->lParam->vkCode)) && (data->wParam == WM_KEYUP || data->wParam == WM_SYSKEYUP))
                {
                    // Release new shortcut, and set original shortcut keys except the one released
                    size_t key_count;
                    LPINPUT keyEventList;
                    if (remapToShortcut)
                    {
                        // if the released key is present in both shortcuts' modifiers (i.e part of the common modifiers)
                        if (std::get<Shortcut>(it->second.targetShortcut).CheckWinKey(data->lParam->vkCode) || std::get<Shortcut>(it->second.targetShortcut).CheckCtrlKey(data->lParam->vkCode) || std::get<Shortcut>(it->second.targetShortcut).CheckAltKey(data->lParam->vkCode) || std::get<Shortcut>(it->second.targetShortcut).CheckShiftKey(data->lParam->vkCode))
                        {
                            // release all new shortcut keys and the common released modifier except the other common modifiers, and add all original shortcut modifiers except the common ones
                            key_count = (dest_size - commonKeys) + (src_size - 1 - commonKeys);
                        }
                        else
                        {
                            // release all new shortcut keys except the common modifiers and add all original shortcut modifiers except the common ones
                            key_count = (dest_size - 1) + (src_size - 2) - (2 * (size_t)commonKeys);
                        }

                        // If the target shortcut's action key is pressed, then it should be released
                        bool isActionKeyPressed = false;
                        if (GetAsyncKeyState(std::get<Shortcut>(it->second.targetShortcut).GetActionKey()) & 0x8000)
                        {
                            isActionKeyPressed = true;
                            key_count += 1;
                        }

                        keyEventList = new INPUT[key_count]();
                        memset(keyEventList, 0, sizeof(keyEventList));

                        // Release new shortcut state (release in reverse order of shortcut to be accurate)
                        int i = 0;
                        if (isActionKeyPressed)
                        {
                            KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)std::get<Shortcut>(it->second.targetShortcut).GetActionKey(), KEYEVENTF_KEYUP, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                            i++;
                        }
                        KeyboardManagerHelper::SetModifierKeyEvents(std::get<Shortcut>(it->second.targetShortcut), it->second.winKeyInvoked, keyEventList, i, false, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG, it->first, data->lParam->vkCode);

                        // Set original shortcut key down state except the action key and the released modifier since the original action key may or may not be held down. If it is held down it will generate it's own key message
                        KeyboardManagerHelper::SetModifierKeyEvents(it->first, it->second.winKeyInvoked, keyEventList, i, true, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG, std::get<Shortcut>(it->second.targetShortcut), data->lParam->vkCode);
                    }
                    else
                    {
                        // 1 for releasing new key and original shortcut modifiers except the one released
                        key_count = dest_size + src_size - 2;
                        // Do not send Disable key up
                        if (std::get<DWORD>(it->second.targetShortcut) == CommonSharedConstants::VK_DISABLED)
                        {
                            key_count--;
                        }

                        keyEventList = new INPUT[key_count]();
                        memset(keyEventList, 0, sizeof(keyEventList));

                        // Release new key state
                        int i = 0;
                        if (std::get<DWORD>(it->second.targetShortcut) != CommonSharedConstants::VK_DISABLED)
                        {
                            KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)KeyboardManagerHelper::FilterArtificialKeys(std::get<DWORD>(it->second.targetShortcut)), KEYEVENTF_KEYUP, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                            i++;
                        }

                        // Set original shortcut key down state except the action key and the released modifier since the original action key may or may not be held down. If it is held down it will generate it's own key message
                        KeyboardManagerHelper::SetModifierKeyEvents(it->first, it->second.winKeyInvoked, keyEventList, i, true, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG, Shortcut(), data->lParam->vkCode);
                    }

                    it->second.isShortcutInvoked = false;
                    it->second.winKeyInvoked = ModifierKey::Disabled;
                    // If app specific shortcut has finished invoking, reset the target application
                    if (activatedApp)
                    {
                        keyboardManagerState.SetActivatedApp(KeyboardManagerConstants::NoActivatedApp);
                    }

                    // key count can be 0 if both shortcuts have same modifiers and the action key is not held down. delete will throw an error if keyEventList is empty
                    if (key_count > 0)
                    {
                        UINT res = ii.SendVirtualInput((UINT)key_count, keyEventList, sizeof(INPUT));
                        delete[] keyEventList;
                    }
                    return 1;
                }

                // The system will see the modifiers of the new shortcut as being held down because of the shortcut remap
                if (!remapToShortcut || std::get<Shortcut>(it->second.targetShortcut).CheckModifiersKeyboardState(ii))
                {
                    // Case 2: If the original shortcut is still held down the keyboard will get a key down message of the action key in the original shortcut and the new shortcut's modifiers will be held down (keys held down send repeated keydown messages)
                    if (data->lParam->vkCode == it->first.GetActionKey() && (data->wParam == WM_KEYDOWN || data->wParam == WM_SYSKEYDOWN))
                    {
                        // In case of mapping to disable do not send anything
                        if (!remapToShortcut && std::get<DWORD>(it->second.targetShortcut) == CommonSharedConstants::VK_DISABLED)
                        {
                            return 1;
                        }

                        size_t key_count = 1;
                        LPINPUT keyEventList = new INPUT[key_count]();
                        memset(keyEventList, 0, sizeof(keyEventList));
                        if (remapToShortcut)
                        {
                            KeyboardManagerHelper::SetKeyEvent(keyEventList, 0, INPUT_KEYBOARD, (WORD)std::get<Shortcut>(it->second.targetShortcut).GetActionKey(), 0, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                        }
                        else
                        {
                            KeyboardManagerHelper::SetKeyEvent(keyEventList, 0, INPUT_KEYBOARD, (WORD)KeyboardManagerHelper::FilterArtificialKeys(std::get<DWORD>(it->second.targetShortcut)), 0, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                        }

                        it->second.isShortcutInvoked = true;
                        UINT res = ii.SendVirtualInput((UINT)key_count, keyEventList, sizeof(INPUT));
                        delete[] keyEventList;
                        return 1;
                    }

                    // Case 3: If the action key is released from the original shortcut keep modifiers of the new shortcut until some other key event which doesn't apply to the original shortcut
                    if (data->lParam->vkCode == it->first.GetActionKey() && (data->wParam == WM_KEYUP || data->wParam == WM_SYSKEYUP))
                    {
                        size_t key_count = 1;
                        LPINPUT keyEventList;
                        if (remapToShortcut)
                        {
                            keyEventList = new INPUT[key_count]();
                            memset(keyEventList, 0, sizeof(keyEventList));
                            KeyboardManagerHelper::SetKeyEvent(keyEventList, 0, INPUT_KEYBOARD, (WORD)std::get<Shortcut>(it->second.targetShortcut).GetActionKey(), KEYEVENTF_KEYUP, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                            it->second.isShortcutInvoked = true;
                        }

                        // for remap from shortcut to key, when the action key is released, the remap invoke is completed so revert to original shortcut state
                        else
                        {
                            // 1 for releasing new key and original shortcut modifiers, and dummy key
                            key_count = dest_size + (src_size - 1) + KeyboardManagerConstants::DUMMY_KEY_EVENT_SIZE;
                            // Do not send Disable key
                            if (std::get<DWORD>(it->second.targetShortcut) == CommonSharedConstants::VK_DISABLED)
                            {
                                key_count--;
                            }

                            keyEventList = new INPUT[key_count]();
                            memset(keyEventList, 0, sizeof(keyEventList));

                            // Release new key state
                            int i = 0;
                            // Do not send Disable key
                            if (std::get<DWORD>(it->second.targetShortcut) != CommonSharedConstants::VK_DISABLED)
                            {
                                KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)KeyboardManagerHelper::FilterArtificialKeys(std::get<DWORD>(it->second.targetShortcut)), KEYEVENTF_KEYUP, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                                i++;
                            }

                            // Set original shortcut key down state except the action key and the released modifier
                            KeyboardManagerHelper::SetModifierKeyEvents(it->first, it->second.winKeyInvoked, keyEventList, i, true, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);

                            // Send dummy key
                            KeyboardManagerHelper::SetDummyKeyEvent(keyEventList, i, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);

                            it->second.isShortcutInvoked = false;
                            it->second.winKeyInvoked = ModifierKey::Disabled;
                            // If app specific shortcut has finished invoking, reset the target application
                            if (activatedApp)
                            {
                                keyboardManagerState.SetActivatedApp(KeyboardManagerConstants::NoActivatedApp);
                            }
                        }

                        UINT res = ii.SendVirtualInput((UINT)key_count, keyEventList, sizeof(INPUT));
                        delete[] keyEventList;
                        return 1;
                    }

                    // Case 4: If a modifier key in the original shortcut is pressed then suppress that key event since the original shortcut is already held down physically - This case can occur only if a user has a duplicated modifier key (possibly by remapping) or if user presses both L/R versions of a modifier remapped with "Both"
                    if ((it->first.CheckWinKey(data->lParam->vkCode) || it->first.CheckCtrlKey(data->lParam->vkCode) || it->first.CheckAltKey(data->lParam->vkCode) || it->first.CheckShiftKey(data->lParam->vkCode)) && (data->wParam == WM_KEYDOWN || data->wParam == WM_SYSKEYDOWN))
                    {
                        if (remapToShortcut)
                        {
                            it->second.isShortcutInvoked = true;

                            // Modifier state reset might be required for this key depending on the target shortcut action key - ex: Ctrl+A -> Win+Caps
                            if (std::get<Shortcut>(it->second.targetShortcut).GetCtrlKey() == NULL && std::get<Shortcut>(it->second.targetShortcut).GetAltKey() == NULL && std::get<Shortcut>(it->second.targetShortcut).GetShiftKey() == NULL)
                            {
                                ResetIfModifierKeyForLowerLevelKeyHandlers(ii, data->lParam->vkCode, std::get<Shortcut>(it->second.targetShortcut).GetActionKey());
                                return 1;
                            }
                        }
                        else if (std::get<DWORD>(it->second.targetShortcut) == CommonSharedConstants::VK_DISABLED)
                        {
                            return 1;
                        }
                    }

                    // Case 5: If any key apart from the action key or a modifier key in the original shortcut is pressed then revert the keyboard state to just the original modifiers being held down along with the current key press
                    if (data->wParam == WM_KEYDOWN || data->wParam == WM_SYSKEYDOWN)
                    {
                        if (remapToShortcut)
                        {
                            // Modifier state reset might be required for this key depending on the target shortcut action key - ex: Ctrl+A -> Win+Caps, Shift is pressed. System should not see Shift and Caps pressed together
                            if (std::get<Shortcut>(it->second.targetShortcut).GetCtrlKey() == NULL && std::get<Shortcut>(it->second.targetShortcut).GetAltKey() == NULL && std::get<Shortcut>(it->second.targetShortcut).GetShiftKey() == NULL)
                            {
                                ResetIfModifierKeyForLowerLevelKeyHandlers(ii, data->lParam->vkCode, std::get<Shortcut>(it->second.targetShortcut).GetActionKey());
                            }

                            size_t key_count;
                            LPINPUT keyEventList;

                            // If the original shortcut is a subset of the new shortcut
                            if (commonKeys == src_size - 1)
                            {
                                key_count = dest_size - commonKeys + KeyboardManagerConstants::DUMMY_KEY_EVENT_SIZE;

                                // If the target shortcut's action key is pressed, then it should be released and original shortcut's action key should be set
                                bool isActionKeyPressed = false;
                                if (GetAsyncKeyState(std::get<Shortcut>(it->second.targetShortcut).GetActionKey()) & 0x8000)
                                {
                                    isActionKeyPressed = true;
                                    key_count += 2;
                                }

                                keyEventList = new INPUT[key_count]();
                                memset(keyEventList, 0, sizeof(keyEventList));

                                int i = 0;
                                if (isActionKeyPressed)
                                {
                                    KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)std::get<Shortcut>(it->second.targetShortcut).GetActionKey(), KEYEVENTF_KEYUP, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                                    i++;
                                }
                                KeyboardManagerHelper::SetModifierKeyEvents(std::get<Shortcut>(it->second.targetShortcut), it->second.winKeyInvoked, keyEventList, i, false, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG, it->first);

                                // key down for original shortcut action key with shortcut flag so that we don't invoke the same shortcut remap again
                                if (isActionKeyPressed)
                                {
                                    KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)it->first.GetActionKey(), 0, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                                    i++;
                                }

                                // Send current key pressed without shortcut flag so that it can be reprocessed in case the physical keys pressed are a different remapped shortcut
                                KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)data->lParam->vkCode, 0, 0);
                                i++;

                                // Send dummy key since the current key pressed could be a modifier
                                KeyboardManagerHelper::SetDummyKeyEvent(keyEventList, i, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                            }
                            else
                            {
                                // Key up for all new shortcut keys, key down for original shortcut modifiers, dummy key and current key press but common keys aren't repeated
                                key_count = (dest_size) + (src_size - 1) + KeyboardManagerConstants::DUMMY_KEY_EVENT_SIZE - (2 * (size_t)commonKeys);

                                // If the target shortcut's action key is pressed, then it should be released and original shortcut's action key should be set
                                bool isActionKeyPressed = false;
                                if (GetAsyncKeyState(std::get<Shortcut>(it->second.targetShortcut).GetActionKey()) & 0x8000)
                                {
                                    isActionKeyPressed = true;
                                    key_count += 2;
                                }

                                keyEventList = new INPUT[key_count]();
                                memset(keyEventList, 0, sizeof(keyEventList));

                                // Release new shortcut state (release in reverse order of shortcut to be accurate)
                                int i = 0;
                                if (isActionKeyPressed)
                                {
                                    KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)std::get<Shortcut>(it->second.targetShortcut).GetActionKey(), KEYEVENTF_KEYUP, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                                    i++;
                                }
                                KeyboardManagerHelper::SetModifierKeyEvents(std::get<Shortcut>(it->second.targetShortcut), it->second.winKeyInvoked, keyEventList, i, false, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG, it->first);

                                // Set old shortcut key down state
                                KeyboardManagerHelper::SetModifierKeyEvents(it->first, it->second.winKeyInvoked, keyEventList, i, true, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG, std::get<Shortcut>(it->second.targetShortcut));

                                // key down for original shortcut action key with shortcut flag so that we don't invoke the same shortcut remap again
                                if (isActionKeyPressed)
                                {
                                    KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)it->first.GetActionKey(), 0, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                                    i++;
                                }

                                // Send current key pressed without shortcut flag so that it can be reprocessed in case the physical keys pressed are a different remapped shortcut
                                KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)data->lParam->vkCode, 0, 0);
                                i++;

                                // Send dummy key
                                KeyboardManagerHelper::SetDummyKeyEvent(keyEventList, i, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                            }

                            it->second.isShortcutInvoked = false;
                            it->second.winKeyInvoked = ModifierKey::Disabled;
                            // If app specific shortcut has finished invoking, reset the target application
                            if (activatedApp)
                            {
                                keyboardManagerState.SetActivatedApp(KeyboardManagerConstants::NoActivatedApp);
                            }

                            UINT res = ii.SendVirtualInput((UINT)key_count, keyEventList, sizeof(INPUT));
                            delete[] keyEventList;
                            return 1;
                        }
                        // All modifier keys and action key will be pressed down because if they are not pressed that means that handler has already been  invoked on key release
                        else if (std::get<DWORD>(it->second.targetShortcut) == CommonSharedConstants::VK_DISABLED)
                        {
                            // Key down for original shortcut modifiers and action key, dummy key, and current key press
                            size_t key_count = src_size + KeyboardManagerConstants::DUMMY_KEY_EVENT_SIZE + 1;

                            LPINPUT keyEventList = new INPUT[key_count]();
                            memset(keyEventList, 0, sizeof(keyEventList));

                            // Set old shortcut key down state
                            int i = 0;
                            KeyboardManagerHelper::SetModifierKeyEvents(it->first, it->second.winKeyInvoked, keyEventList, i, true, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);

                            // Set old action key
                            KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)it->first.GetActionKey(), 0, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);
                            i++;

                            // Send current key pressed without shortcut flag so that it can be reprocessed in case the physical keys pressed are a different remapped shortcut
                            KeyboardManagerHelper::SetKeyEvent(keyEventList, i, INPUT_KEYBOARD, (WORD)data->lParam->vkCode, 0, 0);
                            i++;

                            // Send dummy key
                            KeyboardManagerHelper::SetDummyKeyEvent(keyEventList, i, KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG);

                            it->second.isShortcutInvoked = false;
                            it->second.winKeyInvoked = ModifierKey::Disabled;
                            // If app specific shortcut has finished invoking, reset the target application
                            if (activatedApp != KeyboardManagerConstants::NoActivatedApp)
                            {
                                keyboardManagerState.SetActivatedApp(KeyboardManagerConstants::NoActivatedApp);
                            }

                            UINT res = ii.SendVirtualInput((UINT)key_count, keyEventList, sizeof(INPUT));
                            delete[] keyEventList;
                            return 1;
                        }
                    }
                    // For remap to key, nothing should be done since the shortcut should only get released on releasing any of the original shortcut keys.
                    // Case 6: If any key apart from original modifier or original action key is released - This can't happen since the key down would have to happen first, which is handled above. If a key up message is generated for some other key (maybe by code) do not suppress it
                }
            }
        }

        return 0;
    }

    // Function to a handle an os-level shortcut remap
    __declspec(dllexport) intptr_t HandleOSLevelShortcutRemapEvent(InputInterface& ii, LowlevelKeyboardEvent* data, KeyboardManagerState& keyboardManagerState) noexcept
    {
        // Check if the key event was generated by KeyboardManager to avoid remapping events generated by us.
        if (data->lParam->dwExtraInfo != KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG)
        {
            bool result = HandleShortcutRemapEvent(ii, data, keyboardManagerState);
            return result;
        }

        return 0;
    }

    // Function to a handle an app-specific shortcut remap
    __declspec(dllexport) intptr_t HandleAppSpecificShortcutRemapEvent(InputInterface& ii, LowlevelKeyboardEvent* data, KeyboardManagerState& keyboardManagerState) noexcept
    {
        // Check if the key event was generated by KeyboardManager to avoid remapping events generated by us.
        if (data->lParam->dwExtraInfo != KeyboardManagerConstants::KEYBOARDMANAGER_SHORTCUT_FLAG)
        {
            std::wstring process_name;

            // Allocate MAX_PATH amount of memory
            process_name.resize(MAX_PATH);
            ii.GetForegroundProcess(process_name);

            // Remove elements after null character
            process_name.erase(std::find(process_name.begin(), process_name.end(), L'\0'), process_name.end());

            if (process_name.empty())
            {
                return 0;
            }

            // Convert process name to lower case
            std::transform(process_name.begin(), process_name.end(), process_name.begin(), towlower);

            std::wstring query_string;

            AppSpecificShortcutRemapTable::iterator it;
            // Check if an app-specific shortcut is already activated
            if (keyboardManagerState.GetActivatedApp() == KeyboardManagerConstants::NoActivatedApp)
            {
                query_string = process_name;
                it = keyboardManagerState.appSpecificShortcutReMap.find(query_string);

                // If no entry is found, search for the process name without it's file extension
                if (it == keyboardManagerState.appSpecificShortcutReMap.end())
                {
                    // Find index of the file extension
                    size_t extensionIndex = process_name.find_last_of(L".");
                    query_string = process_name.substr(0, extensionIndex);
                    it = keyboardManagerState.appSpecificShortcutReMap.find(query_string);
                }
            }
            else
            {
                query_string = keyboardManagerState.GetActivatedApp();
                it = keyboardManagerState.appSpecificShortcutReMap.find(query_string);
            }

            if (it != keyboardManagerState.appSpecificShortcutReMap.end())
            {
                bool result = HandleShortcutRemapEvent(ii, data, keyboardManagerState, query_string);
                return result;
            }
        }

        return 0;
    }

    // Function to ensure Num Lock state does not change when it is suppressed by the low level hook
    void SetNumLockToPreviousState(InputInterface& ii)
    {
        // Num Lock's key state is applied before it is intercepted by low level keyboard hooks, so we have to manually set back the state when we suppress the key. This is done by sending an additional key up, key down set of messages.
        // We need 2 key events because after Num Lock is suppressed, key up to release num lock key and key down to revert the num lock state
        int key_count = 2;
        LPINPUT keyEventList = new INPUT[size_t(key_count)]();
        memset(keyEventList, 0, sizeof(keyEventList));

        // Use the suppress flag to ensure these are not intercepted by any remapped keys or shortcuts
        KeyboardManagerHelper::SetKeyEvent(keyEventList, 0, INPUT_KEYBOARD, VK_NUMLOCK, KEYEVENTF_KEYUP, KeyboardManagerConstants::KEYBOARDMANAGER_SUPPRESS_FLAG);
        KeyboardManagerHelper::SetKeyEvent(keyEventList, 1, INPUT_KEYBOARD, VK_NUMLOCK, 0, KeyboardManagerConstants::KEYBOARDMANAGER_SUPPRESS_FLAG);
        UINT res = ii.SendVirtualInput((UINT)key_count, keyEventList, sizeof(INPUT));
        delete[] keyEventList;
    }

    // Function to ensure Ctrl/Shift/Alt modifier key state is not detected as pressed down by applications which detect keys at a lower level than hooks when it is remapped for scenarios where its required
    void ResetIfModifierKeyForLowerLevelKeyHandlers(InputInterface& ii, DWORD key, DWORD target)
    {
        // If the target is Caps Lock and the other key is either Ctrl/Alt/Shift then reset the modifier state to lower level handlers
        if (target == VK_CAPITAL)
        {
            // If the argument is either of the Ctrl/Shift/Alt modifier key codes
            if (KeyboardManagerHelper::IsModifierKey(key) && !(key == VK_LWIN || key == VK_RWIN || key == CommonSharedConstants::VK_WIN_BOTH))
            {
                int key_count = 1;
                LPINPUT keyEventList = new INPUT[size_t(key_count)]();
                memset(keyEventList, 0, sizeof(keyEventList));

                // Use the suppress flag to ensure these are not intercepted by any remapped keys or shortcuts
                KeyboardManagerHelper::SetKeyEvent(keyEventList, 0, INPUT_KEYBOARD, (WORD)key, KEYEVENTF_KEYUP, KeyboardManagerConstants::KEYBOARDMANAGER_SUPPRESS_FLAG);
                UINT res = ii.SendVirtualInput((UINT)key_count, keyEventList, sizeof(INPUT));
                delete[] keyEventList;
            }
        }
    }
}
